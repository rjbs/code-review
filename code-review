#!/usr/bin/env perl
use 5.18.0;
use warnings;

binmode *STDOUT, ':encoding(UTF-8)';
binmode *STDERR, ':encoding(UTF-8)';

use DateTime;
use DateTime::Format::Strptime;
use Getopt::Long::Descriptive;
use List::AllUtils qw(part);
use LWP::UserAgent;
use String::ShellQuote;
use Term::ReadKey ();
use Time::Duration::Parse;
use YAML::XS ();

use lib '/Users/rjbs/fm/code/LP-Tools/lib';
use CliM8::Util qw(activityloop matesay);
use CliM8::HTTP;

use lib 'lib';
require RJBS::CodeReview;

our $http = CliM8::HTTP->new;

$|++;

my @orig_argv = @ARGV;

my ($opt, $usage) = describe_options(
  '%c %o',
  [ 'rebuild'      => "rebuild the YAML file that holds state" ],
  [ 'project|p=s'  => "project to mark reviewed"               ],
  [ 'message|m=s'  => "commit message"                         ],
  [ 'pauseid=s'    => "your PAUSE id",  { default => uc $ENV{USER} } ],
  [ 'githubid=s'   => "your GitHub id", { default =>    $ENV{USER} } ],
  [ 'tmux!'        => 'ensure running under tmux', { default => 1 } ],
  [ 'local-cpan=s' => "where's your local cpan?", { default =>
      "$ENV{HOME}/minicpan/modules/02packages.details.txt.gz" },
  ]
);

die "--message without --rebuild or --project is nonsensical"
  if $opt->message and not ($opt->rebuild or $opt->project);

if ($opt->tmux && ! $ENV{TMUX}) {
  exec {'tmux'} 'tmux', 'new-session', '-n', 'code-review', "$^X $0 " . shell_quote(@ARGV);
  die "Tried to exec tmux but we're still here.  What?!\n";
}

my $mate = RJBS::CodeReview->new({
  http_agent => $http,
  github_id  => $opt->githubid,
});

my $res = $http->do_request(
  uri      => 'https://fastapi.metacpan.org/release/latest_by_author/RJBS',
  m8_label => "consulting MetaCPAN",
)->get;

die "Can't get latest CPAN releases" unless $res->is_success;
my $releases = $mate->decode_json_res($res);

my %is_tracked = map {; $_ => scalar(($mate->_state->{$_}{review} // '') ne 'never') }
                 keys $mate->_state->%*;

my %dist;

DIST: for my $d ($releases->{releases}->@*) {
  my $name = $d->{distribution};
  next if $name eq 'perl';

  $is_tracked{$name} = 1 unless exists $is_tracked{$name};
  $dist{ $name } = $d;
}

our @projects = grep {; $is_tracked{$_} } keys %is_tracked;

my $strp = DateTime::Format::Strptime->new(
  pattern   => '%F',
  locale    => 'en_US',
  time_zone => 'local',
);

my ($undue, $due) = part {
  return 0 unless my $rev = $mate->_state->{$_}{'review-every'};
  die "can't parse duration $rev\n" unless my $dur = parse_duration($rev);
  return 1 if ! $mate->_state->{$_}{'last-review'};
  my $last_done = $strp->parse_datetime($mate->_state->{$_}{'last-review'})->epoch;
  return 1 if time - $last_done > $dur;
  return 0;
} @projects;

@projects = (@{ $due // [] }, sort {
  ($mate->_state->{$a}{'last-review'} // '0') cmp ($mate->_state->{$b}{'last-review'} // 0)
  ||
  fc $a cmp fc $b
} @$undue);

if (@ARGV) {
  my @missing = grep {; ! ($is_tracked{$_} or $mate->_state->{$_}) } @ARGV;
  die "these projects that you asked about are unknown: @missing\n"
    if @missing;
  @projects = @ARGV;
}

if (my $project = $opt->project) {
  die "project $project is not tracked\n" unless $is_tracked{ $project };
  $mate->_state->{$project}{'last-review'}
    = DateTime->now(time_zone => 'local')->format_cldr('yyyy-MM-dd');
}

if ($opt->project) {
  do_review($opt->project, $opt->message);
  exit;
} elsif ($opt->rebuild) {
  do_review(undef, $opt->message);
  exit;
}

activityloop($mate->activity(boot => { projects => \@projects }));

say q{};
matesay("Good job reviewing!");

exit;

sub notes_for {
  my ($name) = @_;

  my $home = $mate->_state->{$name}{home} // 'CPAN';

  if ($home eq 'CPAN') {
    return cpan_notes($name);
  } elsif ($home eq 'GitHub') {
    return gh_notes($name);
  }

  return ("not hosted at CPAN, but at $home");
}

sub rt_data {
  state %rt_data;
  unless (%rt_data) {
    my $res = $http->do_request(
      uri      => 'https://rt.cpan.org/Public/bugs-per-dist.json',
      m8_label => "consulting rt.cpan.org",
    )->get;

    die "Can't get RT bug count JSON" unless $res->is_success;
    my $bug_count = $mate->decode_json_res($res);
    for my $name (@projects) {
      next unless $bug_count->{$name};
      $rt_data{ $name } = {
        open    => 0,
        stalled => 0,
      };

      $rt_data{ $name }{open} = $bug_count->{$name}{counts}{active}
                              - $bug_count->{$name}{counts}{stalled};

      $rt_data{ $name }{stalled} = $bug_count->{$name}{counts}{stalled};
    }
  }

  return \%rt_data;
}

sub cpan_notes {
  my ($name) = @_;

  my $dist = $dist{$name};

  my $uri = $dist
    ? sprintf('https://fastapi.metacpan.org/release/%s/%s',
              $dist->@{ qw(author name) })
    : sprintf('https://fastapi.metacpan.org/release/%s', $name);

  my $res = $http->do_request(
    uri       => $uri,
    m8_label  => "getting release from MetaCPAN",
  )->get;

  # TODO: distinguish 404 from other errors
  return ("couldn't find dist on metacpan") unless $res->is_success;

  my $release = $mate->decode_json_res($res)->{release};

  my @notes;

  my $tracker = $release->{metadata}{resources}{bugtracker};
  if (! $tracker->{web} or $tracker->{web} =~ /rt.cpan/) {
    push @notes, "still using rt.cpan.org";
  }

  my $gh_repo_name = $name;
  my $gh_user = $opt->githubid;

  my $repo = $release->{metadata}{resources}{repository}{url};
  if (! $repo) {
    push @notes, "no repository on file";
  } elsif ($repo !~ /github.com/) {
    push @notes, "not using GitHub for repo";
  } elsif ($repo =~ /\Q$name/i && $repo !~ /\Q$name/) {
    $gh_repo_name = lc $name;
    push @notes, "GitHub repo is not capitalized correctly";
  } elsif ($repo =~ m{github\.com/\Q$gh_user\E/(.+?)(?:\.git)}) {
    $gh_repo_name = $1;
  } elsif ($repo =~ m{github\.com/(.+?)(?:\.git)}) {
    $gh_repo_name = $1;
  }

  push @notes, gh_notes($gh_repo_name);

  my $rt_bugs = rt_data->{$name};
  for (qw(open stalled)) {
    push @notes, "rt.cpan.org $_ ticket count: $rt_bugs->{$_}"
      if $rt_bugs->{$_};
  }

  unless (($release->{metadata}{generated_by} // '') =~ /Dist::Zilla/) {
    push @notes, "dist not built with Dist::Zilla";
  }

  {
    my $res = $http->do_request(
      uri       => "https://cpants.cpanauthors.org/dist/$name.json",
      m8_label  => "checking CPANTS",
    )->get;

    if ($res->is_success) {
      my $data = $mate->decode_json_res($res);
      for my $result (@{ $data->{kwalitee}[0] }) {
        next if $result->{value};
        next if $result->{is_experimental};
        next if $result->{is_extra};
        push @notes, "kwalitee test failed: $result->{name}";
      }
    } else {
      push @notes, "could not get CPANTS results";
    }
  }

  return @notes;
}

sub gh_notes {
  my ($gh_repo_name) = @_;

  my @notes;

  my $gh_user = $opt->githubid;
  my $res = $http->do_request(
    uri       => "https://api.github.com/repos/$gh_user/$gh_repo_name",
    headers   => [ Authorization => "token $ENV{GITHUB_OAUTH_TOKEN}"],
    m8_label  => "talking to GitHub",
  )->get;

  unless ($res->is_success) {
    return ("Couldn't get repo data for $gh_user/$gh_repo_name from GitHub");
  }

  my $repo = $mate->decode_json_res($res);

  push @notes, "GitHub default branch is master"
    if $repo->{default_branch} eq 'master';

  push @notes, "GitHub issues are not enabled"
    if ! $repo->{has_issues};

  push @notes, "GitHub issue count: $repo->{open_issues_count}"
    if $repo->{open_issues_count};

  return @notes;
}
